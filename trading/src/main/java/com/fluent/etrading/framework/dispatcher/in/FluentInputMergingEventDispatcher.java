package com.fluent.etrading.framework.dispatcher.in;

import org.slf4j.*;

import java.util.*;
import java.util.concurrent.*;

import com.fluent.etrading.framework.collections.*;
import com.fluent.etrading.framework.core.*;
import com.fluent.etrading.framework.dispatcher.core.*;
import com.fluent.etrading.framework.events.core.*;
import com.fluent.etrading.framework.events.in.*;
import com.fluent.etrading.framework.persistence.*;

import static com.fluent.etrading.framework.utility.ContainerUtil.*;


/**
 *
 * SmartInputEventDispatcher uses a "smart" design to distribute events that arrive from multiple sources (threads) to listeners.
 * It provides higher throughput and lower latency by relaxing mutual-exclusion provided by locks in <link>BlockingQueue</link> and by introducing "single-writer" principal.
 *
 * Currently, the input events expected by SmartInputEventDispatcher are:

 * AdminEvent       = Events generated by a JMX page or any other administrative tool.
 * LoopbackEvent    = Events send by the output dispatcher
 * RequestEvent     = Events send by the traders using the GUI.
 * ExecutionEvent   = Events containing execution report from the market.
 * ReferenceEvent   = Events containing reference data for instruments.
 * MarketDataEvent  = Events containing Market data.
 *
 * NOTE:
 * The correctness of this class relies on the "single-writer" assumption.
 * Each of the aforementioned events are delivered to this class using ONE single thread.
 * If this assumption doesn't hold true, then switch to the <link>BlockingInputEventDispatcher</link>
 *
 */

public final class FluentInputMergingEventDispatcher extends InputEventDispatcher implements Runnable{

    private volatile boolean keepDispatching;
    
    private final ExecutorService executor;
    private final FluentMPSCQueue<FluentInputEvent> mpscQueue;
    private final FluentSPSCMergingQueue<String,  FluentInputEvent> marketDataQueue;

    private final static int DEFAULT_SIZE	= FOUR * SIXTY_FOUR * SIXTY_FOUR;
    private final static String NAME        = FluentInputMergingEventDispatcher.class.getSimpleName();
    private final static Logger LOGGER      = LoggerFactory.getLogger( NAME );


    public FluentInputMergingEventDispatcher( BackoffStrategy backoff ){
    	this( backoff, null );
    }
    
    
    public FluentInputMergingEventDispatcher( BackoffStrategy backoff, FluentPersister<FluentInputEvent> persister ){
    	this( backoff, persister, new HashSet<FluentInputEventType>( Arrays.asList(FluentInputEventType.EXECUTION_REPORT_UPDATE) ) );
    }
    
    
    public FluentInputMergingEventDispatcher( BackoffStrategy backoff, FluentPersister<FluentInputEvent> persister, Set<FluentInputEventType> recoverables ){
        this( backoff, persister, recoverables, new int[]{DEFAULT_SIZE, DEFAULT_SIZE} );
    }
    
    
    public FluentInputMergingEventDispatcher( BackoffStrategy backoff, FluentPersister<FluentInputEvent> persister, Set<FluentInputEventType> recoverables, int[] capacities ){
        super( backoff, persister, recoverables );

        this.mpscQueue         	= new FluentMPSCQueue<FluentInputEvent>( capacities[ ZERO ] );
        this.marketDataQueue    = new FluentSPSCMergingQueue<String, FluentInputEvent>( capacities[ ONE ] );
        this.executor           = Executors.newSingleThreadExecutor( new FluentThreadFactory(NAME) );

    }

    
    @Override
    public final void startDispatch( ){
        keepDispatching = true;
        executor.execute( this );

        LOGGER.info("[{}] started, using SPCQueues with [{}] as backoff strategy.", NAME, getBackoff().description() );
    }


    @Override
    public final boolean addAdminEvent( final AdminEvent event ){
        return mpscQueue.offer( event );
    }


    @Override
    public final boolean addLoopbackEvent( final LoopbackEvent event ){
        return mpscQueue.offer( event );
    }


    @Override
    public final boolean addRequestEvent( final TraderDataEvent event ){
        return mpscQueue.offer( event );
    }


    @Override
    public final boolean addExecutionEvent( final ExecutionReportEvent event ){
        return mpscQueue.offer( event );
    }


    @Override
    public final boolean addReferenceDataEvent( final ReferenceDataEvent event ){
        return mpscQueue.offer( event );
    }


    @Override
    public final boolean addMarketDataEvent( final MarketDataEvent event ){
        return marketDataQueue.offer( event.getSymbol(), event );
    }


    
    @Override
    public final void run( ){

    	performRecovery( );
    	final List<FluentInputEvent> mdBucket	= new ArrayList<FluentInputEvent>( TWO * SIXTY_FOUR );
    	
        while( keepDispatching ){
        	
        	try{

        		FluentInputEvent otherEvent 	= mpscQueue.poll( );
        		int mdEventsPolledCount			= marketDataQueue.poll( mdBucket, HUNDRED );

        		boolean nothingPolled   		= ( otherEvent == null && mdEventsPolledCount == ZERO );
        		if( nothingPolled ){
        			getBackoff().apply();
        			continue;
        		}
        		
        		
        		if( otherEvent != null ){
        			for( FluentInputEventListener listener : getListeners() ){	
        				if( listener.isSupported( otherEvent.getType() )){
        					listener.update( otherEvent );
        				}
        			}
        		}
        		        		
        		
        		for( FluentInputEvent mdEvent : mdBucket ){
        			if( mdEvent == null ) continue;
        			
        			for( FluentInputEventListener listener : getListeners() ){	
        				if( listener.isSupported( mdEvent.getType() ) ){
        					listener.update( mdEvent );
        				}
        			}
        			
        		}

        		
        		//getPersister().persistAll( adEvent, loEvent, rfEvent, exEvent, rqEvent, mdBucket );

        		if( mdEventsPolledCount > ZERO ){
        			mdBucket.clear();
        		}

        	}catch( Exception e ){
        		LOGGER.error("FAILED to dispatch input events.");
        		LOGGER.error("Exception:", e);
        	}

        }
        
    }
    


    @Override
    public final void stopDispatch( ){
        keepDispatching = false;
        executor.shutdown();

        LOGGER.info("[{}], sucessfully STOPPED", NAME );
    }


}
